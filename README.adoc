= ProPra 2 √úbung 5: Spring Security
13.11.2023
:experimental:
:icons: font
:icon-set: octicon
:source-highlighter: rouge
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

== Vorwort
Diese Woche wollen wir uns mit Spring Security auseinandersetzen. Wir benutzen unsere Rover-Anwendung "Burgertown" von √úbung 5 als Grundlage.

.Ziele der √úbung:
* WebSecurity mit CSRF Protection einrichten
* Single-Sign-On mit GitHub einrichten
* Userinformationen auslesen
* Routen autorisieren
* Security testen


== Basic WebSecurity einrichten
Zun√§chst m√∂chten wir eine Konfigurationsklasse erstellen, mit der wir sp√§ter festgelegen, wie unsere Anwendung abgesichert werden soll.

.Aufgaben:

. Erstellen Sie ein package `de.hhu.propra.rover.configuration` mit einer  `WebSecurityConfiguration` Klasse, welche von `WebSecurityConfigurerAdapter` erbt, und annotieren Sie diese als Configuration.
+
.L√∂sungshilfe
[%collapsible]
=======
[source,java]
----
@Configuration
public class WebSecurityConfiguration extends WebSecurityConfigurerAdapter{ }
----
=======


. Kopieren Sie die folgende Methode in die Klasse und lesen Sie sich durch, was die Methode macht.
+
[source,java]
----
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests(a -> a
                        .antMatchers("/", "/error", "/css/**", "/img/**").permitAll()
                        .anyRequest().permitAll()
                )
                .exceptionHandling(e -> e.authenticationEntryPoint(new HttpStatusEntryPoint(HttpStatus.UNAUTHORIZED)))
                .logout(l -> l.logoutSuccessUrl("/").permitAll());
    }

----


== CSRF Protection
CSRF steht f√ºr Cross-Site-Request-Forgery.
Nehmen Sie an, Sie haben soeben einen neuen Highscore in unserem Spiel aufgestellt.
Dann machen Sie eine kurze Pause und besuchen `evil.com`, wo Sie ein Formular absenden.
Aber anstatt zu der Webseite selbst, geht ihr Post Request vom Browser aus zu `propra-rover.com/deleteMyHighscore` üò±.
Da der Request ganz legitim vom Browser des Users kommt, kann unsere Rover-App nicht wissen, dass der User gar nicht den Highscore l√∂schen m√∂chte.

//Um uns gegen solche seiten√ºbergreifende Trickserei zu sch√ºtzen, k√∂nnen wir ein generiertes Token in unsere Formulare einschleusen, welches wir bei POST-Requests zur√ºckerwarten.
//Dieses Token kann `evil.com` nicht wissen und daher keine CSRF Attacken mehr durchf√ºhren.

.Aufgaben:

. F√ºgen Sie in der `configure` Methode folgende CSRF Protection hinzu.
+
[source,java]
----
    .csrf(c -> c.csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse()))

----

. Starte Sie das Spiel ohne Login und versuchen Sie eine Bewegung auszuf√ºhren. Was sehen Sie?

. Probieren Sie die folgenden beiden Varianten aus, um in den Formularen ein CSRF Token hinzuzuf√ºgen.

.. F√ºgen Sie das CSRF Token als verstecktes Inputfeld in den Formularen hinzu.
+
[source,html]
----
<input th:name="${_csrf.parameterName}" th:value="${_csrf.token}" type="hidden"/>
----

.. Lassen Sie Thymeleaf ein CSRF Token erzeugen, indem Sie `th:action` anstatt `action` in den Formularen verwenden.

. Starten Sie erneut das Spiel und kontrollieren Sie, dass nun die Bewegungen funktionieren.



== GitHub Single-Sign-On
Nun wollen wir √ºber den OAuth2 Standard GitHub als Single-Sign-On Dienst verwenden, um uns zu authentifizieren.

Daf√ºr muss man die Anwendung in GitHub als OAuth Anwendung registrieren. Das ist bereits heute geschehen. Man erh√§lt eine eindeutige `Client ID`. Jede Instanz muss au√üerdem ein **geheimes** `Client Secret` haben, um sich als diese Anwendung bei GitHub zu identifizieren.


.Aufgaben
. Verwenden Sie heute folgende `Client ID` und `Client Secret` und f√ºgen Sie diesen als Umgebungsvariablen in IntelliJ hinzu.
+
|===
|CLIENT_ID | CLIENT_SECRET
|ee34c10933919a8273da
|d3abfcaacee8d25c24c418652578d2bf73210174
|===

+
.Step-by-step Anleitung zum Setzen der Umgebungsvariablen
[%collapsible]
=======
In IntelliJ k√∂nnen Sie die Umgebungsvariablen am einfachsten √ºber die Run Configuration setzen:

image::images/edit.png[]

image::images/add_env.png[]

image::images/add_env_popup.png[]

image::images/popup.png[]

image::images/add.png[]
=======

. Erg√§nzen Sie nun die `application.yml` folgenderma√üen:
+
[source,yaml]
----
spring:
  security:
    oauth2:
      client:
        registration:
          github:
            client-id: ${CLIENT_ID}
            client-secret: ${CLIENT_SECRET}
----
+
[IMPORTANT]
Achten Sie darauf, dass Sie diesen Code *ohne* Einr√ºckung einf√ºgen.

. Passen Sie nun die `WebSecurityConfiguration` folgenderma√üen an:
.. Ersetzen Sie
+
[source,java]
----
.anyRequest().permitAll()
----
durch
+
[source,java]
----
.anyRequest().authenticated()
----

.. Ersetzen Sie
+
[source,java]
----
.logout(l -> l.logoutSuccessUrl("/").permitAll());
----
+
durch
+
[source,java]
----
.logout(l -> l.logoutSuccessUrl("/").permitAll())
.oauth2Login();
----

. Was bewirken diese √Ñnderungen?
Diskutieren Sie.

. Versuchen Sie nun sich √ºber den Link auf der Startseite einzuloggen.


[TIP]
====
In Docker k√∂nnen Sie f√ºr die Client ID und das Client Secret eine `.env` Datei verwenden, welche auf jeden Fall in der `.gitignore` Datei ber√ºcksichtigt werden muss! Im Docker-Compose File k√∂nnen Sie dann die Informationen aus der `.env` Datei als Umgebungsvariable in den Container √ºbertragen.

`compose.yml`:
[source, yaml]
----
version: "3.1"
services:
  application:
    # Konfiguration der Anwendung
    environment:
      - "CLIENT_ID=${CLIENT_ID}"
      - "CLIENT_SECRET=${CLIENT_SECRET}"
----
====


== Userinfos verwenden
Nun m√∂chten wir uns anschauen, wie wir Informationen des eingeloggten Users nun verwenden k√∂nnen. Daf√ºr lassen wir uns von Spring das User-Objekt, das sogenannte `Principal`, ausgeben.

.Aufgaben

. Injecten Sie in die `main` und die `won` Methode des Controllers den `@AuthenticationPrincipal OAuth2User`.

. F√ºgen Sie in den beiden Methoden ein Modelattribut "user" ein, welches mit dem Usernamen gef√ºllt ist, falls es einen eingeloggten User (User-Objekt) gibt.
Den Usernamen erhalten Sie, wenn Sie von `.getAttribute("login")` auf dem User-Objekt aufrufen.
+
.L√∂sungshilfe
[%collapsible]
=======
[source,java]
----
model.addAttribute("user",
        userObject != null ? userObject.getAttribute("login") : null
);
----
=======

. Wie Sie auf der Startseite sehen sollten, gibt es jetzt ein paar neue Buttons. F√ºgen Sie die folgenden Methoden in den `WebController` ein und schauen Sie sich an, was Ihnen dort angezeigt wird.
+
[source,java]
----

@GetMapping("/tokeninfo")
@ResponseBody
public Map<String, Object> tokeninfo(@RegisteredOAuth2AuthorizedClient OAuth2AuthorizedClient authorizedClient) {
    OAuth2AccessToken gitHubAccessToken = authorizedClient.getAccessToken();
    return Map.of("token", gitHubAccessToken);
}

@RequestMapping("/user")
@ResponseBody
public Map<String, Object> user(@AuthenticationPrincipal OAuth2User principal) {
    return principal.getAttributes();
}
----


== Autorisierung

=== Rollen zuordnen
Wir wollen nun unsere User in zwei Gruppen teilen: Administrator:innen und normale Benutzer:innen.



.Aufgaben:
. F√ºgen Sie in der `application.yml` die folgende Rollenkonfigurierung hinzu.
+
[source,yaml]
----
rover:
  rollen:
    admin: bendisposto, lahutar, jaste111
----

. Lassen Sie sich diese in der `WebSecurityConfiguration` Klasse per `@Value`-Annotation injecten.
+
[source,java]
----
@Value("${rover.rollen.admin}")
private Set<String> admins;
----

. Kopieren Sie die folgende Methode, mit welcher der Standard-`OAuth2UserService` √ºberschrieben wird, in die Klasse.
+
[source,java]
----
@Bean
OAuth2UserService<OAuth2UserRequest, OAuth2User> createUserService() {
    DefaultOAuth2UserService defaultService = new DefaultOAuth2UserService();
    return userRequest -> {
        OAuth2User oauth2User = defaultService.loadUser(userRequest);

        var attributes = oauth2User.getAttributes(); //keep existing attributes

        var authorities = new HashSet<GrantedAuthority>();
        authorities.add(new SimpleGrantedAuthority("ROLE_USER"));

        String login = attributes.get("login").toString();
        System.out.printf("USER LOGIN: %s%n", login);

        if (admins.contains(login)) {
            System.out.printf("GRANTING ADMIN PRIVILEGES TO USER %s%n", login);
            authorities.add(new SimpleGrantedAuthority("ROLE_ADMIN"));
        } else {
            System.out.printf("DENYING ADMIN PRIVILEGES TO USER %s%n", login);
        }

        return new DefaultOAuth2User(authorities, attributes, "login");
    };
}
----


=== Routen zug√§nglich machen

Mithilfe von Spring Security k√∂nnen wir Routen nur f√ºr bestimmte Rollen zug√§nglich machen.

.Aufgaben:
. F√ºgen Sie die folgende weitere Konfigurationsklasse hinzu.
+
[source,java]
----
@Configuration
@EnableGlobalMethodSecurity(
        prePostEnabled = true,
        securedEnabled = true,
        jsr250Enabled = true)
public class MethodSecurityConfiguration extends GlobalMethodSecurityConfiguration {}
----

. F√ºgen Sie die folgende Methode in den Controller ein.
+
[source,java]
----
@GetMapping("/admin")
public String admin(Model model, @AuthenticationPrincipal OAuth2User principal) {
    model.addAttribute("user",
            principal != null ? principal.getAttribute("login") : null
    );
    return "admin";
}
----

. F√ºgen Sie eine Annotation hinzu, damit die `/admin` Route nur noch f√ºr Personen mit der Rolle `ROLE_ADMIN` zug√§nglich ist.
+
.L√∂sungshilfe
[%collapsible]
=======
[source,java]
----
@Secured("ROLE_ADMIN")
----
=======

. Probieren Sie diese Route nun aus. K√∂nnen Sie als normaler User darauf zugreifen? Was passiert, wenn Sie Ihren GitHub-Namen als Admin eintragen und dann auf diese Route zugreifen?


.Bonusaufgabe (wenn Zeit √ºbrig ist)
. F√ºgen Sie eine neue Rolle hinzu und schreiben Sie eine Handlermethode, f√ºr eine Route, die nur f√ºr diese Rolle freigegeben ist.



== BONUS: Testing
Um unsere Anwendung nun weiterhin testen zu k√∂nnen, ben√∂tigen wir ein paar Helferklassen, die Sie bereits unter `helper` finden. Damit k√∂nnen wir uns eingeloggte User simulieren.

.Aufgaben:
. Importieren Sie die Konfigurationsklassen in die `WebController` Klasse mithilfe der `@Import` Annotation.
+
.L√∂sungshilfe
[%collapsible]
=======
[source,java]
----
@Import(MethodSecurityConfiguration.class)
----
=======

. Testen Sie, dass Sie ohne Anmeldung keinen Zugriff auf `/game` haben.
+
.L√∂sungsvorschlag
[%collapsible]
========
[source, java]
----
@Test
void UnauthorizedWithoutLogin() throws Exception {
    mockMvc.perform(get("/game")).andExpect(status().isUnauthorized());
}
----
========

. Testen Sie nun mithilfe unserer vorgegebenen `WithMockOAuth2User` Annotation einen Zugriff auf `/game` durch einen eingeloggten User.
+
.L√∂sungshilfe
[%collapsible]
========
[source, java]
----
@WithMockOAuth2User(login = "Max Mustermann", roles = {"USER"})
----
========

. Wir k√∂nnen bei dem `@WithMockOAuth2User` auch Rollen festlegen. Schreiben Sie weitere Tests, mit denen die verschiedenen Zugriffe auf `/admin` getestet werden.

